# T2.4: Price Rules Temporal Design

**Priority:** Medium  
**Phase:** 2  
**Estimated Time:** 2 days  
**Risk Level:** üü° Medium  
**Dependencies:** None

---

## üéØ Problem Statement

### **Current Flawed Design:**

Price rules have **UNIQUE constraint** that prevents price history:

```sql
price_rules (
    id UUID PRIMARY KEY,
    book_id UUID FK,
    sku_id UUID FK,
    price NUMERIC(18,2),
    valid_from TIMESTAMPTZ,
    valid_to TIMESTAMPTZ,
    
    -- ‚ùå PROBLEM: UNIQUE prevents multiple price versions!
    UNIQUE(book_id, sku_id)
);
```

### **Critical Problems:**

1. ‚ùå **Price Changes Overwrite History**
   - Product price updated: ‚Çπ10,000 ‚Üí ‚Çπ12,000 ‚Üí ‚Çπ15,000
   - Old prices lost forever
   - Can't answer: "What was the price in Q1 2024?"

2. ‚ùå **No Promotional Pricing History**
   - Diwali sale: ‚Çπ15,000 ‚Üí ‚Çπ12,000 (Oct 15-31)
   - Regular price resumes after
   - Have to UPDATE existing record, loses history

3. ‚ùå **Can't Schedule Future Prices**
   - Want to set: "Price increases to ‚Çπ20,000 on Jan 1, 2025"
   - UNIQUE constraint blocks this
   - Can't have current + future price simultaneously

4. ‚ùå **Financial Audit Impossible**
   - Finance asks: "What price did we charge customer X on June 15?"
   - No historical data = can't answer
   - Compliance risk for contracts

5. ‚ùå **No Overlap Prevention**
   - Multiple prices can have overlapping date ranges
   - Which price applies? Undefined!
   - Database doesn't enforce temporal integrity

6. ‚ùå **Price Book Changes Overwrite**
   - Seasonal price book changes
   - Summer ‚Üí Monsoon ‚Üí Winter
   - Each change loses previous pricing

---

## ‚úÖ Correct Design

### **Version-Controlled Price Rules:**

```sql
-- price_books: Price book metadata (unchanged)
price_books (
    id UUID PRIMARY KEY,
    name TEXT,                  -- 'Summer 2024', 'Hospital Tier-1', etc.
    org_id UUID FK,             -- Organization-specific pricing
    channel_id UUID FK,         -- Channel-specific pricing
    currency TEXT DEFAULT 'INR',
    status TEXT,                -- active, inactive, archived
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
);

-- price_rules: Version-controlled prices (NEW DESIGN)
price_rules (
    id UUID PRIMARY KEY,
    book_id UUID FK,
    sku_id UUID FK,
    version INT,                -- 1, 2, 3, ... (sequential)
    
    -- Pricing
    price NUMERIC(18,2) NOT NULL,
    currency TEXT DEFAULT 'INR',
    
    -- Temporal validity
    valid_from TIMESTAMPTZ NOT NULL,
    valid_to TIMESTAMPTZ,       -- NULL = currently active
    
    -- Pricing context
    pricing_type TEXT,          -- regular, promotional, seasonal, contract
    min_quantity INT,           -- Volume discounts
    max_quantity INT,
    discount_percentage NUMERIC(5,2),
    
    -- Audit trail
    changed_by TEXT,
    changed_at TIMESTAMPTZ,
    change_reason TEXT,
    approved_by TEXT,
    
    -- Metadata
    notes TEXT,
    metadata JSONB,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Constraints
    CONSTRAINT valid_dates CHECK (
        valid_to IS NULL OR valid_to >= valid_from
    ),
    CONSTRAINT version_positive CHECK (version > 0),
    CONSTRAINT price_positive CHECK (price > 0),
    
    -- NO UNIQUE on (book_id, sku_id) - allow multiple versions!
    UNIQUE(book_id, sku_id, version),
    
    -- Prevent overlapping prices for same book+sku
    EXCLUDE USING gist (
        book_id WITH =,
        sku_id WITH =,
        tstzrange(valid_from, COALESCE(valid_to, '9999-12-31'::timestamptz), '[]') WITH &&
    )
);
```

### **Benefits:**

‚úÖ **Complete Price History** - Track all price changes  
‚úÖ **Promotional Pricing** - Schedule sales with automatic revert  
‚úÖ **Future Price Scheduling** - Set prices weeks/months ahead  
‚úÖ **Financial Audit Trail** - Historical pricing for compliance  
‚úÖ **No Overlap** - Database enforces one price at any point in time  
‚úÖ **Temporal Queries** - "What was the price on date X?"

---

## üîß Key Features

### **1. Temporal Price Queries**
```sql
-- Get current price for SKU
SELECT price, pricing_type
FROM price_rules
WHERE book_id = 'book-uuid'
    AND sku_id = 'sku-uuid'
    AND valid_to IS NULL;

-- Get price on specific date (e.g., for invoice verification)
SELECT price, pricing_type, version
FROM price_rules
WHERE book_id = 'book-uuid'
    AND sku_id = 'sku-uuid'
    AND '2024-06-15' >= valid_from
    AND ('2024-06-15' <= valid_to OR valid_to IS NULL);

-- Get complete price history
SELECT version, price, valid_from, valid_to, 
       pricing_type, change_reason
FROM price_rules
WHERE book_id = 'book-uuid'
    AND sku_id = 'sku-uuid'
ORDER BY version DESC;
```

### **2. Schedule Future Prices**
```sql
-- Current price: ‚Çπ15,000
-- Schedule price increase for Jan 1, 2025
INSERT INTO price_rules (
    book_id, sku_id, version, price,
    valid_from, pricing_type, changed_by, change_reason
) VALUES (
    'book-uuid', 'sku-uuid', 2, 20000.00,
    '2025-01-01 00:00:00+00', 'regular',
    'pricing_manager@company.com', 'Annual price revision'
);

-- Database now has TWO active records:
-- Version 1: ‚Çπ15,000 (valid_to = '2024-12-31 23:59:59')
-- Version 2: ‚Çπ20,000 (valid_from = '2025-01-01', valid_to = NULL)
```

### **3. Promotional Pricing**
```sql
-- Regular price: ‚Çπ15,000
-- Add Diwali sale: ‚Çπ12,000 (Oct 15-31)
INSERT INTO price_rules (
    book_id, sku_id, version, price,
    valid_from, valid_to, pricing_type,
    discount_percentage, changed_by, change_reason
) VALUES (
    'book-uuid', 'sku-uuid', 3, 12000.00,
    '2024-10-15 00:00:00+00', '2024-10-31 23:59:59+00',
    'promotional', 20.00,
    'marketing@company.com', 'Diwali Festival Sale'
);

-- After Oct 31, price automatically reverts to regular
```

### **4. Version Management**
```sql
-- Function to update price (creates new version)
CREATE FUNCTION update_price(
    p_book_id UUID,
    p_sku_id UUID,
    p_new_price NUMERIC,
    p_valid_from TIMESTAMPTZ,
    p_changed_by TEXT,
    p_reason TEXT
) RETURNS UUID AS $$
DECLARE
    v_new_version INT;
    v_new_id UUID;
BEGIN
    -- Close current price
    UPDATE price_rules
    SET valid_to = p_valid_from
    WHERE book_id = p_book_id
        AND sku_id = p_sku_id
        AND valid_to IS NULL;
    
    -- Get next version
    SELECT COALESCE(MAX(version), 0) + 1 INTO v_new_version
    FROM price_rules
    WHERE book_id = p_book_id AND sku_id = p_sku_id;
    
    -- Insert new version
    INSERT INTO price_rules (
        book_id, sku_id, version, price,
        valid_from, changed_by, changed_at, change_reason
    ) VALUES (
        p_book_id, p_sku_id, v_new_version, p_new_price,
        p_valid_from, p_changed_by, NOW(), p_reason
    )
    RETURNING id INTO v_new_id;
    
    RETURN v_new_id;
END;
$$ LANGUAGE plpgsql;
```

### **5. No Overlap Enforcement**
```sql
-- This prevents:
-- Price A: valid_from=Jan 1, valid_to=Dec 31
-- Price B: valid_from=Jun 1, valid_to=Aug 31
-- Both active in July - which one applies?

EXCLUDE USING gist (
    book_id WITH =,
    sku_id WITH =,
    tstzrange(valid_from, valid_to) WITH &&
)
-- Database automatically rejects overlapping ranges!
```

---

## üìã Migration Strategy

### **Step 1: Remove UNIQUE Constraint**
```sql
-- Drop unique constraint that blocks versioning
ALTER TABLE price_rules 
DROP CONSTRAINT IF EXISTS price_rules_book_id_sku_id_key;
```

### **Step 2: Add Version Control Columns**
```sql
-- Add versioning
ALTER TABLE price_rules
ADD COLUMN IF NOT EXISTS version INT DEFAULT 1,
ADD COLUMN IF NOT EXISTS pricing_type TEXT DEFAULT 'regular',
ADD COLUMN IF NOT EXISTS changed_by TEXT,
ADD COLUMN IF NOT EXISTS changed_at TIMESTAMPTZ DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS change_reason TEXT,
ADD COLUMN IF NOT EXISTS approved_by TEXT,
ADD COLUMN IF NOT EXISTS notes TEXT;

-- Set version for existing records
UPDATE price_rules SET version = 1 WHERE version IS NULL;

-- Make version NOT NULL
ALTER TABLE price_rules ALTER COLUMN version SET NOT NULL;
```

### **Step 3: Add New Constraints**
```sql
-- Version-based unique
ALTER TABLE price_rules
ADD CONSTRAINT price_rules_version_unique 
UNIQUE(book_id, sku_id, version);

-- No overlap constraint
CREATE EXTENSION IF NOT EXISTS btree_gist;

ALTER TABLE price_rules
ADD CONSTRAINT price_rules_no_overlap
EXCLUDE USING gist (
    book_id WITH =,
    sku_id WITH =,
    tstzrange(valid_from, COALESCE(valid_to, '9999-12-31'::timestamptz), '[]') WITH &&
);
```

### **Step 4: Migrate Existing Data**
```sql
-- Mark existing prices as version 1
UPDATE price_rules
SET 
    version = 1,
    pricing_type = 'regular',
    changed_by = 'migration_T2.4',
    changed_at = NOW(),
    change_reason = 'Initial price version from migration';
```

### **Step 5: Create Helper Functions**
```sql
CREATE FUNCTION update_price(...);
CREATE FUNCTION get_current_price(...);
CREATE FUNCTION get_price_at_date(...);
CREATE FUNCTION get_price_history(...);
```

### **Step 6: Create Views**
```sql
-- View: Current prices only
CREATE VIEW current_prices AS
SELECT
    pr.id,
    pr.book_id,
    pb.name as book_name,
    pr.sku_id,
    pr.price,
    pr.currency,
    pr.pricing_type,
    pr.valid_from,
    pr.version
FROM price_rules pr
JOIN price_books pb ON pr.book_id = pb.id
WHERE pr.valid_to IS NULL;
```

---

## üí° Use Case Examples

### **Example 1: Regular Price Increase**
```sql
-- Increase MRI Scanner price from ‚Çπ15L to ‚Çπ18L
SELECT update_price(
    'hospital-tier1-book',
    'mri-scanner-3t-sku',
    1800000.00,
    '2025-01-01 00:00:00+00',
    'pricing_manager@company.com',
    'Annual price revision 2025'
);
```

### **Example 2: Seasonal Promotion**
```sql
-- Summer sale: 15% off for 2 months
INSERT INTO price_rules (
    book_id, sku_id, version, price,
    valid_from, valid_to,
    pricing_type, discount_percentage,
    changed_by, change_reason
) VALUES (
    'retail-book', 'ultrasound-portable',
    4, 425000.00,  -- Regular: ‚Çπ5L, Sale: ‚Çπ4.25L
    '2025-04-01', '2025-05-31',
    'promotional', 15.00,
    'sales@company.com', 'Summer clearance sale'
);
```

### **Example 3: Volume Discount Pricing**
```sql
-- Add tiered pricing: 1-5 units vs 6+ units
-- Tier 1: 1-5 units @ ‚Çπ10,000 each
INSERT INTO price_rules (
    book_id, sku_id, version, price,
    min_quantity, max_quantity,
    valid_from, pricing_type, change_reason
) VALUES (
    'distributor-book', 'pulse-oximeter',
    1, 10000.00, 1, 5,
    NOW(), 'volume', 'Standard retail pricing'
);

-- Tier 2: 6+ units @ ‚Çπ8,500 each
INSERT INTO price_rules (
    book_id, sku_id, version, price,
    min_quantity, max_quantity,
    valid_from, pricing_type, change_reason
) VALUES (
    'distributor-book', 'pulse-oximeter',
    2, 8500.00, 6, NULL,
    NOW(), 'volume', 'Bulk order discount'
);
```

### **Example 4: Invoice Price Verification**
```sql
-- Customer invoice from June 15, 2024 shows ‚Çπ15,000
-- Verify correct price was charged
SELECT 
    price,
    pricing_type,
    version,
    change_reason
FROM price_rules
WHERE book_id = 'hospital-book'
    AND sku_id = 'ecg-machine-12-lead'
    AND '2024-06-15' >= valid_from
    AND ('2024-06-15' <= valid_to OR valid_to IS NULL);

-- Returns: ‚Çπ15,000, regular, v2, "Q2 2024 pricing"
-- ‚úÖ Correct price confirmed for audit
```

### **Example 5: Price Trend Analysis**
```sql
-- Analyze price changes over last 2 years
SELECT
    version,
    price,
    valid_from,
    valid_to,
    pricing_type,
    ROUND(
        (price - LAG(price) OVER (ORDER BY version)) * 100.0 / 
        LAG(price) OVER (ORDER BY version),
        2
    ) as price_change_percent,
    change_reason
FROM price_rules
WHERE book_id = 'corporate-book'
    AND sku_id = 'ventilator-icu'
    AND valid_from >= NOW() - INTERVAL '2 years'
ORDER BY version;

-- Shows price trend with % changes
```

---

## üìä Benefits

### **Before T2.4:**
- ‚ùå Price changes overwrite history
- ‚ùå Can't schedule future prices
- ‚ùå No promotional pricing support
- ‚ùå Financial audit impossible
- ‚ùå Overlapping dates allowed (confusion)

### **After T2.4:**
- ‚úÖ Complete price history
- ‚úÖ Schedule prices months ahead
- ‚úÖ Promotional pricing with auto-revert
- ‚úÖ Financial audit compliance
- ‚úÖ Database enforces temporal integrity

---

## üß™ Testing Checklist

- [ ] Version control columns added
- [ ] UNIQUE constraint removed
- [ ] No-overlap constraint works
- [ ] Existing prices migrated as v1
- [ ] Helper functions created
- [ ] Views work correctly
- [ ] Can schedule future prices
- [ ] Promotional pricing works
- [ ] Temporal queries accurate
- [ ] No data loss

---

## üîÑ Rollback Procedure

```sql
-- Revert to old design (if needed within migration window)
ALTER TABLE price_rules
DROP CONSTRAINT IF EXISTS price_rules_no_overlap,
DROP CONSTRAINT IF EXISTS price_rules_version_unique,
DROP COLUMN IF EXISTS version,
DROP COLUMN IF EXISTS pricing_type,
DROP COLUMN IF EXISTS changed_by,
DROP COLUMN IF EXISTS changed_at,
DROP COLUMN IF EXISTS change_reason;

-- Re-add simple unique
ALTER TABLE price_rules
ADD CONSTRAINT price_rules_book_id_sku_id_key 
UNIQUE(book_id, sku_id);

-- Note: Loses version history!
```

---

## ‚úÖ Acceptance Criteria

- [ ] Multiple price versions per SKU supported
- [ ] Temporal queries work (<100ms)
- [ ] Future price scheduling works
- [ ] Promotional pricing works
- [ ] No overlapping prices possible
- [ ] Complete price history tracked
- [ ] Zero downtime migration
- [ ] Backward compatible views

---

**Status:** üü° Ready for Implementation  
**Next:** Create SQL migration script

This completes the **temporal trilogy** with T2.1 (org terms) and T2.3 (engineer coverage)! üöÄ
