# Ticket T1.1: Service Ticket Assignment Refactor

**Phase:** 1 - Critical Fixes  
**Priority:** üî¥ Critical  
**Effort:** 2 days  
**Risk:** Low

---

## üìã Problem Statement

Currently, `service_tickets` table stores assignment data inline, which prevents tracking:
- Multiple engineer assignments (escalations)
- Assignment history and audit trail
- Why assignments changed
- Time spent per engineer

**Current Schema:**
```sql
service_tickets (
    assigned_engineer_id VARCHAR,
    assigned_engineer_name VARCHAR,
    assignment_tier INT,
    assignment_tier_name TEXT
)
```

**Impact:**
- Lost escalation history
- Can't track L1 ‚Üí L2 ‚Üí L3 engineer changes
- Can't query "average escalations per ticket"
- Can't bill for multiple engineer time

---

## üéØ Objective

Use the existing `engineer_assignments` table exclusively for all assignment tracking. Remove redundant fields from `service_tickets`.

---

## üìä Current vs Target State

### **Before:**
```
service_tickets
‚îú‚îÄ‚îÄ id
‚îú‚îÄ‚îÄ assigned_engineer_id    ‚ùå Remove
‚îú‚îÄ‚îÄ assigned_engineer_name  ‚ùå Remove
‚îú‚îÄ‚îÄ assignment_tier         ‚ùå Remove
‚îî‚îÄ‚îÄ assignment_tier_name    ‚ùå Remove

engineer_assignments
‚îî‚îÄ‚îÄ (exists but underutilized)
```

### **After:**
```
service_tickets
‚îú‚îÄ‚îÄ id
‚îî‚îÄ‚îÄ (no assignment fields)

engineer_assignments ‚≠ê PRIMARY SOURCE
‚îú‚îÄ‚îÄ id
‚îú‚îÄ‚îÄ ticket_id
‚îú‚îÄ‚îÄ engineer_id
‚îú‚îÄ‚îÄ assignment_sequence       ‚úÖ NEW
‚îú‚îÄ‚îÄ assignment_tier
‚îú‚îÄ‚îÄ assignment_reason         ‚úÖ NEW
‚îú‚îÄ‚îÄ status
‚îú‚îÄ‚îÄ rejection_reason          ‚úÖ NEW
‚îú‚îÄ‚îÄ escalation_reason         ‚úÖ NEW
‚îú‚îÄ‚îÄ completion_status         ‚úÖ NEW
‚îî‚îÄ‚îÄ time_spent_hours          ‚úÖ NEW
```

---

## üóÉÔ∏è SQL Migration

### **File:** `migrations/phase1/001_ticket_assignment.up.sql`

```sql
-- ============================================================================
-- Migration 001: Service Ticket Assignment Refactor
-- Purpose: Remove inline assignment from service_tickets, enhance engineer_assignments
-- ============================================================================

BEGIN;

-- Step 1: Enhance engineer_assignments table with new fields
ALTER TABLE engineer_assignments
ADD COLUMN IF NOT EXISTS assignment_sequence INT DEFAULT 1,
ADD COLUMN IF NOT EXISTS assignment_reason TEXT,
ADD COLUMN IF NOT EXISTS rejection_reason TEXT,
ADD COLUMN IF NOT EXISTS escalation_reason TEXT,
ADD COLUMN IF NOT EXISTS completion_status TEXT,
ADD COLUMN IF NOT EXISTS time_spent_hours NUMERIC(5,2),
ADD COLUMN IF NOT EXISTS notes TEXT;

-- Add check constraint for completion_status
ALTER TABLE engineer_assignments
ADD CONSTRAINT chk_completion_status 
CHECK (completion_status IN ('success', 'failed', 'escalated', 'parts_required', 'customer_unavailable'));

-- Create index for fast current assignment lookup
CREATE INDEX IF NOT EXISTS idx_ea_current_assignment 
ON engineer_assignments(ticket_id, assigned_at DESC) 
WHERE status NOT IN ('completed', 'rejected', 'failed');

-- Step 2: Create view for current assignments (backward compatibility)
CREATE OR REPLACE VIEW current_ticket_assignments AS
SELECT DISTINCT ON (ticket_id)
    ticket_id,
    engineer_id,
    assignment_sequence,
    assignment_tier,
    status,
    assigned_at,
    completed_at
FROM engineer_assignments
WHERE status NOT IN ('completed', 'rejected', 'failed')
ORDER BY ticket_id, assigned_at DESC;

-- Step 3: Backfill existing assignment data
INSERT INTO engineer_assignments (
    id,
    ticket_id,
    engineer_id,
    assignment_sequence,
    assignment_tier,
    assignment_type,
    status,
    assigned_at,
    accepted_at,
    started_at,
    completed_at,
    created_at,
    updated_at
)
SELECT 
    gen_random_uuid(),
    st.id::uuid,
    st.assigned_engineer_id::uuid,
    1,  -- First assignment
    st.assignment_tier,
    'manual',
    CASE 
        WHEN st.status IN ('resolved', 'closed') THEN 'completed'
        WHEN st.status IN ('assigned', 'in_progress') THEN 'in_progress'
        ELSE 'assigned'
    END,
    st.assigned_at,
    st.assigned_at,  -- Assume immediate acceptance for old data
    st.started_at,
    st.resolved_at,
    st.created_at,
    st.updated_at
FROM service_tickets st
WHERE st.assigned_engineer_id IS NOT NULL
  AND st.assigned_engineer_id != ''
  -- Don't duplicate if already exists
  AND NOT EXISTS (
      SELECT 1 FROM engineer_assignments ea 
      WHERE ea.ticket_id::text = st.id 
        AND ea.engineer_id::text = st.assigned_engineer_id
  );

-- Step 4: Add comment for documentation
COMMENT ON TABLE engineer_assignments IS 
'Complete assignment history for service tickets. 
Tracks all engineers assigned to a ticket including escalations.
Current assignment is the latest row where status NOT IN (completed, rejected, failed).';

-- Step 5: Mark old columns as deprecated (don't drop yet for safety)
COMMENT ON COLUMN service_tickets.assigned_engineer_id IS 
'DEPRECATED: Use engineer_assignments table. Will be removed in next release.';

COMMENT ON COLUMN service_tickets.assigned_engineer_name IS 
'DEPRECATED: Use engineer_assignments table. Will be removed in next release.';

COMMENT ON COLUMN service_tickets.assignment_tier IS 
'DEPRECATED: Use engineer_assignments table. Will be removed in next release.';

COMMENT ON COLUMN service_tickets.assignment_tier_name IS 
'DEPRECATED: Use engineer_assignments table. Will be removed in next release.';

COMMIT;
```

### **File:** `migrations/phase1/001_ticket_assignment.down.sql`

```sql
-- ============================================================================
-- Rollback 001: Service Ticket Assignment Refactor
-- ============================================================================

BEGIN;

-- Step 1: Copy current assignments back to service_tickets
UPDATE service_tickets st
SET 
    assigned_engineer_id = cta.engineer_id::text,
    assignment_tier = cta.assignment_tier,
    assigned_at = cta.assigned_at
FROM current_ticket_assignments cta
WHERE st.id = cta.ticket_id::text;

-- Step 2: Drop view
DROP VIEW IF EXISTS current_ticket_assignments;

-- Step 3: Remove new columns from engineer_assignments
ALTER TABLE engineer_assignments
DROP COLUMN IF EXISTS assignment_sequence,
DROP COLUMN IF EXISTS assignment_reason,
DROP COLUMN IF EXISTS rejection_reason,
DROP COLUMN IF EXISTS escalation_reason,
DROP COLUMN IF EXISTS completion_status,
DROP COLUMN IF EXISTS time_spent_hours,
DROP COLUMN IF EXISTS notes;

-- Step 4: Drop new indexes
DROP INDEX IF EXISTS idx_ea_current_assignment;

-- Step 5: Remove comments
COMMENT ON COLUMN service_tickets.assigned_engineer_id IS NULL;
COMMENT ON COLUMN service_tickets.assigned_engineer_name IS NULL;
COMMENT ON COLUMN service_tickets.assignment_tier IS NULL;
COMMENT ON COLUMN service_tickets.assignment_tier_name IS NULL;

COMMIT;
```

---

## üíª Backend Code Changes

### **File:** `internal/service-domain/service-ticket/domain/ticket.go`

```go
// BEFORE: Inline assignment
type ServiceTicket struct {
    ID                   string    `json:"id"`
    AssignedEngineerID   string    `json:"assigned_engineer_id"`   // ‚ùå Remove
    AssignedEngineerName string    `json:"assigned_engineer_name"` // ‚ùå Remove
    AssignmentTier       int       `json:"assignment_tier"`        // ‚ùå Remove
    AssignmentTierName   string    `json:"assignment_tier_name"`   // ‚ùå Remove
    // ... other fields
}

// AFTER: Clean ticket without assignment
type ServiceTicket struct {
    ID     string `json:"id"`
    // ... other fields (no assignment fields)
}

// Add new method to get current assignment
func (t *ServiceTicket) CurrentAssignment(ctx context.Context, repo AssignmentRepository) (*EngineerAssignment, error) {
    return repo.GetCurrentAssignmentByTicketID(ctx, t.ID)
}
```

### **File:** `internal/service-domain/service-ticket/domain/assignment.go`

```go
// NEW FILE: Enhanced assignment model
package domain

import (
    "time"
    "github.com/google/uuid"
)

type EngineerAssignment struct {
    ID                 uuid.UUID  `json:"id"`
    TicketID           uuid.UUID  `json:"ticket_id"`
    EngineerID         uuid.UUID  `json:"engineer_id"`
    EquipmentID        uuid.UUID  `json:"equipment_id"`
    
    // Sequence tracking
    AssignmentSequence int        `json:"assignment_sequence"` // 1, 2, 3...
    AssignmentTier     int        `json:"assignment_tier"`     // 1=OEM, 2=Dealer, etc.
    AssignmentTierName string     `json:"assignment_tier_name"`
    AssignmentReason   string     `json:"assignment_reason"`   // "Initial", "Escalation"
    
    // Workflow
    AssignmentType     string     `json:"assignment_type"`     // "auto", "manual"
    Status             string     `json:"status"`              // assigned|accepted|in_progress|completed
    AssignedBy         uuid.UUID  `json:"assigned_by"`
    AssignedAt         time.Time  `json:"assigned_at"`
    AcceptedAt         *time.Time `json:"accepted_at,omitempty"`
    RejectedAt         *time.Time `json:"rejected_at,omitempty"`
    RejectionReason    string     `json:"rejection_reason,omitempty"`
    
    // Execution
    StartedAt          *time.Time `json:"started_at,omitempty"`
    CompletedAt        *time.Time `json:"completed_at,omitempty"`
    CompletionStatus   string     `json:"completion_status,omitempty"` // success|failed|escalated
    EscalationReason   string     `json:"escalation_reason,omitempty"`
    TimeSpentHours     float64    `json:"time_spent_hours"`
    
    // Details
    Diagnosis          string     `json:"diagnosis,omitempty"`
    ActionsTaken       string     `json:"actions_taken,omitempty"`
    PartsUsed          []Part     `json:"parts_used,omitempty"`
    
    // Customer feedback
    CustomerRating     int        `json:"customer_rating,omitempty"` // 1-5
    CustomerFeedback   string     `json:"customer_feedback,omitempty"`
    
    // Audit
    CreatedAt          time.Time  `json:"created_at"`
    UpdatedAt          time.Time  `json:"updated_at"`
}

type Part struct {
    PartNumber string  `json:"part_number"`
    PartName   string  `json:"part_name"`
    Quantity   int     `json:"quantity"`
    Cost       float64 `json:"cost"`
}

// Repository interface
type AssignmentRepository interface {
    Create(ctx context.Context, assignment *EngineerAssignment) error
    GetByID(ctx context.Context, id uuid.UUID) (*EngineerAssignment, error)
    GetCurrentAssignmentByTicketID(ctx context.Context, ticketID string) (*EngineerAssignment, error)
    GetAssignmentHistoryByTicketID(ctx context.Context, ticketID string) ([]*EngineerAssignment, error)
    Update(ctx context.Context, assignment *EngineerAssignment) error
    UpdateStatus(ctx context.Context, id uuid.UUID, status string) error
}
```

### **File:** `internal/service-domain/service-ticket/app/service.go`

```go
// BEFORE: Inline assignment
func (s *Service) AssignTicket(ctx context.Context, ticketID, engineerID string, tier int) error {
    ticket, err := s.repo.GetByID(ctx, ticketID)
    if err != nil {
        return err
    }
    
    ticket.AssignedEngineerID = engineerID  // ‚ùå Old way
    ticket.AssignmentTier = tier
    
    return s.repo.Update(ctx, ticket)
}

// AFTER: Use assignments table
func (s *Service) AssignTicket(ctx context.Context, req AssignTicketRequest) (*EngineerAssignment, error) {
    // Get current assignment count for sequence
    history, err := s.assignmentRepo.GetAssignmentHistoryByTicketID(ctx, req.TicketID)
    if err != nil {
        return nil, fmt.Errorf("failed to get assignment history: %w", err)
    }
    
    assignment := &EngineerAssignment{
        ID:                 uuid.New(),
        TicketID:           uuid.MustParse(req.TicketID),
        EngineerID:         uuid.MustParse(req.EngineerID),
        EquipmentID:        uuid.MustParse(req.EquipmentID),
        AssignmentSequence: len(history) + 1,
        AssignmentTier:     req.Tier,
        AssignmentTierName: req.TierName,
        AssignmentReason:   req.Reason,
        AssignmentType:     req.Type,
        Status:             "assigned",
        AssignedBy:         uuid.MustParse(req.AssignedBy),
        AssignedAt:         time.Now(),
        CreatedAt:          time.Now(),
        UpdatedAt:          time.Now(),
    }
    
    if err := s.assignmentRepo.Create(ctx, assignment); err != nil {
        return nil, fmt.Errorf("failed to create assignment: %w", err)
    }
    
    // Update ticket status to "assigned"
    if err := s.ticketRepo.UpdateStatus(ctx, req.TicketID, "assigned"); err != nil {
        return nil, fmt.Errorf("failed to update ticket status: %w", err)
    }
    
    return assignment, nil
}

// NEW: Escalate ticket to next tier
func (s *Service) EscalateTicket(ctx context.Context, req EscalateTicketRequest) (*EngineerAssignment, error) {
    // Mark current assignment as failed/escalated
    current, err := s.assignmentRepo.GetCurrentAssignmentByTicketID(ctx, req.TicketID)
    if err != nil {
        return nil, fmt.Errorf("failed to get current assignment: %w", err)
    }
    
    current.Status = "escalated"
    current.CompletedAt = ptrTime(time.Now())
    current.CompletionStatus = "escalated"
    current.EscalationReason = req.Reason
    
    if err := s.assignmentRepo.Update(ctx, current); err != nil {
        return nil, fmt.Errorf("failed to update current assignment: %w", err)
    }
    
    // Create new assignment at higher tier
    return s.AssignTicket(ctx, AssignTicketRequest{
        TicketID:   req.TicketID,
        EngineerID: req.NextEngineerID,
        EquipmentID: current.EquipmentID.String(),
        Tier:       current.AssignmentTier + 1,
        TierName:   req.NextTierName,
        Reason:     "Escalation from previous tier",
        Type:       "auto",
        AssignedBy: req.EscalatedBy,
    })
}

// DTOs
type AssignTicketRequest struct {
    TicketID    string `json:"ticket_id"`
    EngineerID  string `json:"engineer_id"`
    EquipmentID string `json:"equipment_id"`
    Tier        int    `json:"tier"`
    TierName    string `json:"tier_name"`
    Reason      string `json:"reason"`
    Type        string `json:"type"` // "auto", "manual"
    AssignedBy  string `json:"assigned_by"`
}

type EscalateTicketRequest struct {
    TicketID        string `json:"ticket_id"`
    Reason          string `json:"reason"`
    NextEngineerID  string `json:"next_engineer_id"`
    NextTierName    string `json:"next_tier_name"`
    EscalatedBy     string `json:"escalated_by"`
}

func ptrTime(t time.Time) *time.Time {
    return &t
}
```

### **File:** `internal/service-domain/service-ticket/infra/assignment_repository.go`

```go
// NEW FILE: Assignment repository implementation
package infra

import (
    "context"
    "database/sql"
    "fmt"
    
    "github.com/google/uuid"
    "github.com/aby-med/medical-platform/internal/service-domain/service-ticket/domain"
)

type PostgresAssignmentRepository struct {
    db *sql.DB
}

func NewPostgresAssignmentRepository(db *sql.DB) *PostgresAssignmentRepository {
    return &PostgresAssignmentRepository{db: db}
}

func (r *PostgresAssignmentRepository) Create(ctx context.Context, a *domain.EngineerAssignment) error {
    query := `
        INSERT INTO engineer_assignments (
            id, ticket_id, engineer_id, equipment_id,
            assignment_sequence, assignment_tier, assignment_tier_name, assignment_reason,
            assignment_type, status, assigned_by, assigned_at,
            created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
    `
    
    _, err := r.db.ExecContext(ctx, query,
        a.ID, a.TicketID, a.EngineerID, a.EquipmentID,
        a.AssignmentSequence, a.AssignmentTier, a.AssignmentTierName, a.AssignmentReason,
        a.AssignmentType, a.Status, a.AssignedBy, a.AssignedAt,
        a.CreatedAt, a.UpdatedAt,
    )
    
    return err
}

func (r *PostgresAssignmentRepository) GetCurrentAssignmentByTicketID(ctx context.Context, ticketID string) (*domain.EngineerAssignment, error) {
    query := `
        SELECT 
            id, ticket_id, engineer_id, equipment_id,
            assignment_sequence, assignment_tier, assignment_tier_name, assignment_reason,
            assignment_type, status, assigned_by, assigned_at,
            accepted_at, rejected_at, rejection_reason,
            started_at, completed_at, completion_status, escalation_reason,
            time_spent_hours, diagnosis, actions_taken,
            customer_rating, customer_feedback,
            created_at, updated_at
        FROM engineer_assignments
        WHERE ticket_id = $1
          AND status NOT IN ('completed', 'rejected', 'failed')
        ORDER BY assigned_at DESC
        LIMIT 1
    `
    
    var a domain.EngineerAssignment
    err := r.db.QueryRowContext(ctx, query, ticketID).Scan(
        &a.ID, &a.TicketID, &a.EngineerID, &a.EquipmentID,
        &a.AssignmentSequence, &a.AssignmentTier, &a.AssignmentTierName, &a.AssignmentReason,
        &a.AssignmentType, &a.Status, &a.AssignedBy, &a.AssignedAt,
        &a.AcceptedAt, &a.RejectedAt, &a.RejectionReason,
        &a.StartedAt, &a.CompletedAt, &a.CompletionStatus, &a.EscalationReason,
        &a.TimeSpentHours, &a.Diagnosis, &a.ActionsTaken,
        &a.CustomerRating, &a.CustomerFeedback,
        &a.CreatedAt, &a.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, fmt.Errorf("no active assignment found for ticket %s", ticketID)
    }
    
    return &a, err
}

func (r *PostgresAssignmentRepository) GetAssignmentHistoryByTicketID(ctx context.Context, ticketID string) ([]*domain.EngineerAssignment, error) {
    query := `
        SELECT 
            id, ticket_id, engineer_id, equipment_id,
            assignment_sequence, assignment_tier, assignment_tier_name, assignment_reason,
            assignment_type, status, assigned_by, assigned_at,
            accepted_at, rejected_at, rejection_reason,
            started_at, completed_at, completion_status, escalation_reason,
            time_spent_hours, diagnosis, actions_taken,
            customer_rating, customer_feedback,
            created_at, updated_at
        FROM engineer_assignments
        WHERE ticket_id = $1
        ORDER BY assignment_sequence ASC, assigned_at ASC
    `
    
    rows, err := r.db.QueryContext(ctx, query, ticketID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var assignments []*domain.EngineerAssignment
    for rows.Next() {
        var a domain.EngineerAssignment
        if err := rows.Scan(
            &a.ID, &a.TicketID, &a.EngineerID, &a.EquipmentID,
            &a.AssignmentSequence, &a.AssignmentTier, &a.AssignmentTierName, &a.AssignmentReason,
            &a.AssignmentType, &a.Status, &a.AssignedBy, &a.AssignedAt,
            &a.AcceptedAt, &a.RejectedAt, &a.RejectionReason,
            &a.StartedAt, &a.CompletedAt, &a.CompletionStatus, &a.EscalationReason,
            &a.TimeSpentHours, &a.Diagnosis, &a.ActionsTaken,
            &a.CustomerRating, &a.CustomerFeedback,
            &a.CreatedAt, &a.UpdatedAt,
        ); err != nil {
            return nil, err
        }
        assignments = append(assignments, &a)
    }
    
    return assignments, rows.Err()
}

func (r *PostgresAssignmentRepository) Update(ctx context.Context, a *domain.EngineerAssignment) error {
    query := `
        UPDATE engineer_assignments
        SET 
            status = $2,
            accepted_at = $3,
            rejected_at = $4,
            rejection_reason = $5,
            started_at = $6,
            completed_at = $7,
            completion_status = $8,
            escalation_reason = $9,
            time_spent_hours = $10,
            diagnosis = $11,
            actions_taken = $12,
            customer_rating = $13,
            customer_feedback = $14,
            updated_at = $15
        WHERE id = $1
    `
    
    a.UpdatedAt = time.Now()
    
    _, err := r.db.ExecContext(ctx, query,
        a.ID, a.Status,
        a.AcceptedAt, a.RejectedAt, a.RejectionReason,
        a.StartedAt, a.CompletedAt, a.CompletionStatus, a.EscalationReason,
        a.TimeSpentHours, a.Diagnosis, a.ActionsTaken,
        a.CustomerRating, a.CustomerFeedback,
        a.UpdatedAt,
    )
    
    return err
}
```

---

## üåê Frontend Code Changes

### **File:** `admin-ui/src/lib/api/assignments.ts`

```typescript
// NEW FILE: Assignment API client
import { apiClient } from './client';

export interface EngineerAssignment {
  id: string;
  ticket_id: string;
  engineer_id: string;
  equipment_id: string;
  assignment_sequence: number;
  assignment_tier: number;
  assignment_tier_name: string;
  assignment_reason: string;
  status: 'assigned' | 'accepted' | 'in_progress' | 'completed' | 'rejected' | 'failed';
  assigned_at: string;
  accepted_at?: string;
  completed_at?: string;
  time_spent_hours?: number;
  customer_rating?: number;
}

export const assignmentsApi = {
  // Get current assignment for a ticket
  getCurrentAssignment: async (ticketId: string): Promise<EngineerAssignment> => {
    const { data } = await apiClient.get(`/tickets/${ticketId}/current-assignment`);
    return data;
  },

  // Get full assignment history
  getAssignmentHistory: async (ticketId: string): Promise<EngineerAssignment[]> => {
    const { data } = await apiClient.get(`/tickets/${ticketId}/assignments`);
    return data;
  },

  // Assign ticket to engineer
  assignTicket: async (request: {
    ticket_id: string;
    engineer_id: string;
    equipment_id: string;
    tier: number;
    tier_name: string;
    reason: string;
  }): Promise<EngineerAssignment> => {
    const { data } = await apiClient.post('/assignments', request);
    return data;
  },

  // Escalate ticket
  escalateTicket: async (request: {
    ticket_id: string;
    reason: string;
    next_engineer_id: string;
    next_tier_name: string;
  }): Promise<EngineerAssignment> => {
    const { data } = await apiClient.post('/assignments/escalate', request);
    return data;
  },

  // Accept assignment
  acceptAssignment: async (assignmentId: string): Promise<void> => {
    await apiClient.post(`/assignments/${assignmentId}/accept`);
  },

  // Complete assignment
  completeAssignment: async (
    assignmentId: string,
    data: {
      completion_status: 'success' | 'failed' | 'escalated';
      time_spent_hours: number;
      diagnosis?: string;
      actions_taken?: string;
    }
  ): Promise<void> => {
    await apiClient.post(`/assignments/${assignmentId}/complete`, data);
  },
};
```

### **File:** `admin-ui/src/components/tickets/AssignmentHistory.tsx`

```typescript
// NEW COMPONENT: Shows assignment history
import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { assignmentsApi, EngineerAssignment } from '@/lib/api/assignments';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { formatDistance } from 'date-fns';

interface AssignmentHistoryProps {
  ticketId: string;
}

export function AssignmentHistory({ ticketId }: AssignmentHistoryProps) {
  const { data: assignments, isLoading } = useQuery({
    queryKey: ['assignments', ticketId],
    queryFn: () => assignmentsApi.getAssignmentHistory(ticketId),
  });

  if (isLoading) {
    return <div>Loading assignment history...</div>;
  }

  if (!assignments || assignments.length === 0) {
    return <div>No assignments yet</div>;
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Assignment History</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {assignments.map((assignment, index) => (
            <AssignmentCard 
              key={assignment.id} 
              assignment={assignment} 
              isLatest={index === assignments.length - 1}
            />
          ))}
        </div>
      </CardContent>
    </Card>
  );
}

function AssignmentCard({ 
  assignment, 
  isLatest 
}: { 
  assignment: EngineerAssignment; 
  isLatest: boolean;
}) {
  const statusColors = {
    assigned: 'bg-blue-100 text-blue-800',
    accepted: 'bg-green-100 text-green-800',
    in_progress: 'bg-yellow-100 text-yellow-800',
    completed: 'bg-green-100 text-green-800',
    rejected: 'bg-red-100 text-red-800',
    failed: 'bg-red-100 text-red-800',
  };

  return (
    <div className={`border rounded-lg p-4 ${isLatest ? 'border-blue-500' : 'border-gray-200'}`}>
      <div className="flex justify-between items-start mb-2">
        <div>
          <div className="flex items-center gap-2">
            <span className="font-semibold">Assignment #{assignment.assignment_sequence}</span>
            {isLatest && <Badge variant="outline">Current</Badge>}
          </div>
          <p className="text-sm text-gray-600">{assignment.assignment_tier_name}</p>
        </div>
        <Badge className={statusColors[assignment.status]}>
          {assignment.status}
        </Badge>
      </div>

      <div className="text-sm space-y-1">
        <p><strong>Engineer:</strong> {assignment.engineer_id}</p>
        <p><strong>Assigned:</strong> {formatDistance(new Date(assignment.assigned_at), new Date(), { addSuffix: true })}</p>
        {assignment.completed_at && (
          <p><strong>Completed:</strong> {formatDistance(new Date(assignment.completed_at), new Date(), { addSuffix: true })}</p>
        )}
        {assignment.time_spent_hours && (
          <p><strong>Time Spent:</strong> {assignment.time_spent_hours} hours</p>
        )}
        {assignment.customer_rating && (
          <p><strong>Rating:</strong> {'‚≠ê'.repeat(assignment.customer_rating)}</p>
        )}
      </div>
    </div>
  );
}
```

---

## ‚úÖ Testing Checklist

### **Unit Tests:**
- [ ] Test `AssignTicket` creates correct assignment
- [ ] Test `EscalateTicket` marks old as escalated, creates new
- [ ] Test `GetCurrentAssignment` returns latest active
- [ ] Test `GetAssignmentHistory` returns all in order
- [ ] Test assignment sequence increments correctly

### **Integration Tests:**
- [ ] Test migration up + down
- [ ] Test backfill creates assignments from existing tickets
- [ ] Test view `current_ticket_assignments` returns correct data
- [ ] Test concurrent assignments don't cause race conditions

### **Manual Testing:**
- [ ] Create ticket and assign engineer
- [ ] Escalate ticket to next tier
- [ ] View assignment history in UI
- [ ] Verify old tickets have backfilled data
- [ ] Test rollback migration

---

## üìä Acceptance Criteria

- [ ] Migration runs successfully on test database
- [ ] All existing tickets have assignments backfilled
- [ ] New assignment API works end-to-end
- [ ] Escalation flow tracks L1 ‚Üí L2 ‚Üí L3
- [ ] Frontend displays assignment history correctly
- [ ] Query performance < 100ms for current assignment
- [ ] Rollback restores previous state without data loss
- [ ] Code review approved by 2+ engineers

---

## üîÑ Rollback Procedure

If issues found in production:

1. Run rollback migration: `001_ticket_assignment.down.sql`
2. Verify data copied back to `service_tickets`
3. Deploy old application code
4. Monitor for 24 hours
5. Investigate root cause before retry

---

## üìù Documentation Updates

- [ ] Update API documentation with new endpoints
- [ ] Update ER diagram to reflect changes
- [ ] Add assignment workflow diagram
- [ ] Update developer guide with escalation examples
- [ ] Create runbook for common assignment scenarios

---

**Status:** üìù Ready for Implementation  
**Assigned To:** [Developer Name]  
**Due Date:** [Date]
