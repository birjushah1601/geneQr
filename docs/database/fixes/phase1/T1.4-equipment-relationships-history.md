# T1.4: Equipment Relationships History Table

**Priority:** Critical  
**Phase:** 1  
**Estimated Time:** 2 days  
**Dependencies:** None

---

## ðŸŽ¯ Problem Statement

### **Current Flawed Design:**

Equipment relationships are **static and cannot track changes over time**:

```sql
equipment_registry (
    id VARCHAR(32) PRIMARY KEY,
    customer_id VARCHAR(32),          -- âŒ Static - what if sold?
    customer_name VARCHAR(500),       -- âŒ What if customer renamed?
    installation_location TEXT,       -- âŒ What if equipment moved?
    installation_address JSONB,       -- âŒ Can't track location history
    contract_id VARCHAR(32),          -- âŒ What if contract changes?
    amc_contract_id VARCHAR(32),      -- âŒ What if AMC renewed?
    ...
)
```

### **Critical Problems:**

1. âŒ **No Ownership History** - Hospital sells equipment â†’ lost history
2. âŒ **No Location Tracking** - Equipment moved from ICU to ER â†’ can't track
3. âŒ **No Transfer Records** - Lease/rental scenarios not supported
4. âŒ **No Temporal Queries** - Can't ask: "Who owned this on Jan 15, 2024?"
5. âŒ **No Relationship Chain** - Can't track: Manufacturer â†’ Distributor â†’ Dealer â†’ Hospital
6. âŒ **No Audit Trail** - No record of why/when relationships changed

### **Real-World Scenarios That Fail:**

1. **Equipment Transfer:**
   - Hospital A sells CT Scanner to Hospital B
   - Need to track: sold date, reason, transfer documents

2. **Location Changes:**
   - Equipment moved from ICU to ER
   - Need history: Which floor? Which room? When?

3. **Ownership Changes:**
   - Equipment under lease, then purchased
   - Need to track ownership transitions

4. **Multi-Party Relationships:**
   - Same equipment has: Manufacturer, Distributor, Dealer, Owner, Facility
   - Current design can only store one relationship type

5. **Temporal Queries:**
   - "Show all equipment owned by Hospital X on March 2024"
   - "Which facility had this equipment during warranty claim?"
   - IMPOSSIBLE with current design!

---

## âœ… Correct Design

### **Equipment Relationships History Table:**

```sql
CREATE TABLE equipment_relationships (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Equipment reference
    equipment_id VARCHAR(32) NOT NULL REFERENCES equipment_registry(id),
    
    -- Relationship type
    relationship_type VARCHAR(50) NOT NULL,
    -- 'manufacturer', 'distributor', 'dealer', 'owner', 'facility', 
    -- 'service_provider', 'leasing_company'
    
    -- Related entity (organization or facility)
    related_org_id UUID,            -- References organizations table
    related_facility_id UUID,       -- For facility/location relationships
    
    -- Entity details (denormalized for historical accuracy)
    entity_name VARCHAR(500) NOT NULL,
    entity_type VARCHAR(50),        -- 'hospital', 'clinic', 'dealer', etc.
    
    -- Location details (for facility relationships)
    location_details JSONB,         -- Building, floor, room, ward
    address JSONB,                  -- Full address at time of relationship
    
    -- Temporal validity
    effective_from DATE NOT NULL,
    effective_to DATE,              -- NULL means current/active
    
    -- Relationship details
    relationship_status VARCHAR(50) NOT NULL DEFAULT 'active',
    -- 'active', 'terminated', 'transferred', 'expired'
    
    -- Transfer/change information
    reason VARCHAR(255),            -- "Equipment sold", "Moved to ER", "Lease ended"
    transfer_type VARCHAR(50),      -- 'sale', 'lease', 'transfer', 'relocation'
    transfer_documents JSONB,       -- Invoice, contract, agreement URLs
    
    -- Financial details (if applicable)
    transaction_amount DECIMAL(15,2),
    transaction_currency VARCHAR(3),
    contract_reference VARCHAR(100),
    
    -- Metadata
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by VARCHAR(255),
    terminated_at TIMESTAMPTZ,
    terminated_by VARCHAR(255),
    termination_reason TEXT,
    
    -- Constraints
    CONSTRAINT relationship_type_check CHECK (
        relationship_type IN (
            'manufacturer', 'distributor', 'dealer', 'owner', 
            'facility', 'service_provider', 'leasing_company', 'other'
        )
    ),
    CONSTRAINT relationship_status_check CHECK (
        relationship_status IN ('active', 'terminated', 'transferred', 'expired')
    ),
    CONSTRAINT effective_dates_valid CHECK (
        effective_to IS NULL OR effective_to >= effective_from
    ),
    -- Prevent overlapping active relationships of same type
    EXCLUDE USING gist (
        equipment_id WITH =,
        relationship_type WITH =,
        daterange(effective_from, COALESCE(effective_to, '9999-12-31'::date), '[]') WITH &&
    )
);

-- Indexes for performance
CREATE INDEX idx_equipment_rel_equipment ON equipment_relationships(equipment_id);
CREATE INDEX idx_equipment_rel_type ON equipment_relationships(relationship_type);
CREATE INDEX idx_equipment_rel_org ON equipment_relationships(related_org_id) WHERE related_org_id IS NOT NULL;
CREATE INDEX idx_equipment_rel_facility ON equipment_relationships(related_facility_id) WHERE related_facility_id IS NOT NULL;
CREATE INDEX idx_equipment_rel_status ON equipment_relationships(relationship_status);
CREATE INDEX idx_equipment_rel_dates ON equipment_relationships(effective_from, effective_to);

-- Index for "current" relationships
CREATE INDEX idx_equipment_rel_current ON equipment_relationships(equipment_id, relationship_type)
    WHERE relationship_status = 'active' AND effective_to IS NULL;

-- GIN index for location searches
CREATE INDEX idx_equipment_rel_location ON equipment_relationships USING gin(location_details);
CREATE INDEX idx_equipment_rel_address ON equipment_relationships USING gin(address);
```

---

## ðŸ“‹ Migration Strategy

### **Phase 1: Create Table & Migrate Existing Data**

```sql
-- 1. Create equipment_relationships table
CREATE TABLE equipment_relationships (...);

-- 2. Migrate current ownership/location from equipment_registry
INSERT INTO equipment_relationships (
    equipment_id,
    relationship_type,
    related_org_id,
    entity_name,
    location_details,
    address,
    effective_from,
    relationship_status,
    reason,
    created_by
)
SELECT
    id as equipment_id,
    'owner' as relationship_type,
    customer_id::uuid as related_org_id,
    customer_name as entity_name,
    jsonb_build_object('location', installation_location) as location_details,
    installation_address as address,
    COALESCE(installation_date, created_at::date) as effective_from,
    'active' as relationship_status,
    'Migrated from equipment_registry' as reason,
    'migration_T1.4' as created_by
FROM equipment_registry
WHERE customer_id IS NOT NULL;

-- 3. Migrate facility/location information
INSERT INTO equipment_relationships (
    equipment_id,
    relationship_type,
    entity_name,
    location_details,
    address,
    effective_from,
    relationship_status,
    reason,
    created_by
)
SELECT
    id as equipment_id,
    'facility' as relationship_type,
    customer_name || ' - ' || installation_location as entity_name,
    jsonb_build_object(
        'location', installation_location,
        'facility_name', customer_name
    ) as location_details,
    installation_address as address,
    COALESCE(installation_date, created_at::date) as effective_from,
    'active' as relationship_status,
    'Migrated from equipment_registry' as reason,
    'migration_T1.4' as created_by
FROM equipment_registry
WHERE installation_location IS NOT NULL;
```

### **Phase 2: Add Helper Functions**

```sql
-- Function to get current owner
CREATE OR REPLACE FUNCTION get_current_owner(p_equipment_id VARCHAR)
RETURNS TABLE (
    owner_id UUID,
    owner_name VARCHAR,
    since_date DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        er.related_org_id as owner_id,
        er.entity_name as owner_name,
        er.effective_from as since_date
    FROM equipment_relationships er
    WHERE er.equipment_id = p_equipment_id
        AND er.relationship_type = 'owner'
        AND er.relationship_status = 'active'
        AND er.effective_to IS NULL
    ORDER BY er.effective_from DESC
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- Function to get owner at specific date
CREATE OR REPLACE FUNCTION get_owner_at_date(
    p_equipment_id VARCHAR,
    p_date DATE
)
RETURNS TABLE (
    owner_id UUID,
    owner_name VARCHAR,
    from_date DATE,
    to_date DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        er.related_org_id as owner_id,
        er.entity_name as owner_name,
        er.effective_from as from_date,
        er.effective_to as to_date
    FROM equipment_relationships er
    WHERE er.equipment_id = p_equipment_id
        AND er.relationship_type = 'owner'
        AND p_date >= er.effective_from
        AND (er.effective_to IS NULL OR p_date <= er.effective_to)
    ORDER BY er.effective_from DESC
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- Function to transfer equipment
CREATE OR REPLACE FUNCTION transfer_equipment(
    p_equipment_id VARCHAR,
    p_new_owner_id UUID,
    p_new_owner_name VARCHAR,
    p_transfer_date DATE,
    p_reason VARCHAR,
    p_transfer_type VARCHAR,
    p_amount DECIMAL,
    p_created_by VARCHAR
)
RETURNS UUID AS $$
DECLARE
    v_new_rel_id UUID;
BEGIN
    -- Close current ownership
    UPDATE equipment_relationships
    SET effective_to = p_transfer_date,
        relationship_status = 'transferred',
        terminated_at = NOW(),
        terminated_by = p_created_by,
        termination_reason = p_reason
    WHERE equipment_id = p_equipment_id
        AND relationship_type = 'owner'
        AND relationship_status = 'active'
        AND effective_to IS NULL;
    
    -- Create new ownership
    INSERT INTO equipment_relationships (
        equipment_id,
        relationship_type,
        related_org_id,
        entity_name,
        effective_from,
        relationship_status,
        reason,
        transfer_type,
        transaction_amount,
        created_by
    ) VALUES (
        p_equipment_id,
        'owner',
        p_new_owner_id,
        p_new_owner_name,
        p_transfer_date,
        'active',
        p_reason,
        p_transfer_type,
        p_amount,
        p_created_by
    )
    RETURNING id INTO v_new_rel_id;
    
    RETURN v_new_rel_id;
END;
$$ LANGUAGE plpgsql;
```

### **Phase 3: Create Views for Easy Access**

```sql
-- View: Current equipment relationships
CREATE OR REPLACE VIEW equipment_current_relationships AS
SELECT
    er.equipment_id,
    er.relationship_type,
    er.related_org_id,
    er.entity_name,
    er.location_details,
    er.effective_from,
    er.created_at
FROM equipment_relationships er
WHERE er.relationship_status = 'active'
    AND er.effective_to IS NULL;

-- View: Equipment with current owner and location
CREATE OR REPLACE VIEW equipment_with_current_info AS
SELECT
    e.*,
    owner.entity_name as current_owner_name,
    owner.related_org_id as current_owner_id,
    owner.effective_from as owner_since,
    facility.entity_name as current_facility_name,
    facility.location_details as current_location
FROM equipment_registry e
LEFT JOIN equipment_relationships owner ON (
    e.id = owner.equipment_id
    AND owner.relationship_type = 'owner'
    AND owner.relationship_status = 'active'
    AND owner.effective_to IS NULL
)
LEFT JOIN equipment_relationships facility ON (
    e.id = facility.equipment_id
    AND facility.relationship_type = 'facility'
    AND facility.relationship_status = 'active'
    AND facility.effective_to IS NULL
);
```

---

## ðŸ’» Backend Changes

### **Domain Model** (`internal/equipment/domain/equipment_relationship.go`)

```go
package domain

import (
    "errors"
    "time"
)

type RelationshipType string

const (
    RelationshipTypeManufacturer     RelationshipType = "manufacturer"
    RelationshipTypeDistributor      RelationshipType = "distributor"
    RelationshipTypeDealer           RelationshipType = "dealer"
    RelationshipTypeOwner            RelationshipType = "owner"
    RelationshipTypeFacility         RelationshipType = "facility"
    RelationshipTypeServiceProvider  RelationshipType = "service_provider"
    RelationshipTypeLeasingCompany   RelationshipType = "leasing_company"
)

type RelationshipStatus string

const (
    RelationshipStatusActive      RelationshipStatus = "active"
    RelationshipStatusTerminated  RelationshipStatus = "terminated"
    RelationshipStatusTransferred RelationshipStatus = "transferred"
    RelationshipStatusExpired     RelationshipStatus = "expired"
)

type EquipmentRelationship struct {
    ID                 string             `json:"id"`
    EquipmentID        string             `json:"equipment_id"`
    RelationshipType   RelationshipType   `json:"relationship_type"`
    RelatedOrgID       string             `json:"related_org_id,omitempty"`
    RelatedFacilityID  string             `json:"related_facility_id,omitempty"`
    EntityName         string             `json:"entity_name"`
    EntityType         string             `json:"entity_type,omitempty"`
    LocationDetails    map[string]interface{} `json:"location_details,omitempty"`
    Address            map[string]interface{} `json:"address,omitempty"`
    EffectiveFrom      time.Time          `json:"effective_from"`
    EffectiveTo        *time.Time         `json:"effective_to,omitempty"`
    RelationshipStatus RelationshipStatus `json:"relationship_status"`
    Reason             string             `json:"reason,omitempty"`
    TransferType       string             `json:"transfer_type,omitempty"`
    TransactionAmount  float64            `json:"transaction_amount,omitempty"`
    Notes              string             `json:"notes,omitempty"`
    CreatedAt          time.Time          `json:"created_at"`
    CreatedBy          string             `json:"created_by"`
}

// NewEquipmentRelationship creates a new equipment relationship
func NewEquipmentRelationship(
    equipmentID string,
    relType RelationshipType,
    entityName string,
    effectiveFrom time.Time,
    createdBy string,
) *EquipmentRelationship {
    return &EquipmentRelationship{
        ID:                 generateID(),
        EquipmentID:        equipmentID,
        RelationshipType:   relType,
        EntityName:         entityName,
        EffectiveFrom:      effectiveFrom,
        RelationshipStatus: RelationshipStatusActive,
        CreatedAt:          time.Now(),
        CreatedBy:          createdBy,
    }
}

// Terminate ends the relationship
func (er *EquipmentRelationship) Terminate(reason, terminatedBy string) error {
    if er.RelationshipStatus != RelationshipStatusActive {
        return errors.New("relationship not active")
    }
    
    now := time.Now()
    er.EffectiveTo = &now
    er.RelationshipStatus = RelationshipStatusTerminated
    er.Notes += "\nTerminated: " + reason
    return nil
}

// IsActive checks if relationship is currently active
func (er *EquipmentRelationship) IsActive() bool {
    return er.RelationshipStatus == RelationshipStatusActive && er.EffectiveTo == nil
}

// IsCurrent checks if relationship is active on given date
func (er *EquipmentRelationship) IsCurrentOn(date time.Time) bool {
    if date.Before(er.EffectiveFrom) {
        return false
    }
    if er.EffectiveTo != nil && date.After(*er.EffectiveTo) {
        return false
    }
    return true
}
```

---

## ðŸ§ª Testing Checklist

### **Database Migration:**
- [ ] equipment_relationships table created
- [ ] All indexes created successfully
- [ ] Existing equipment migrated to relationships
- [ ] Helper functions working
- [ ] Views created and queryable
- [ ] Rollback script tested

### **Data Validation:**
- [ ] All equipment have at least one owner relationship
- [ ] No overlapping active relationships of same type
- [ ] Temporal queries return correct results
- [ ] Current owner queries match old data

### **Functionality:**
- [ ] Transfer equipment works
- [ ] Terminate relationship works
- [ ] Query owner at specific date works
- [ ] Get relationship history works
- [ ] Location tracking works

---

## ðŸ”„ Rollback Procedure

```sql
-- Drop views
DROP VIEW IF EXISTS equipment_with_current_info CASCADE;
DROP VIEW IF EXISTS equipment_current_relationships CASCADE;

-- Drop functions
DROP FUNCTION IF EXISTS transfer_equipment CASCADE;
DROP FUNCTION IF EXISTS get_owner_at_date CASCADE;
DROP FUNCTION IF EXISTS get_current_owner CASCADE;

-- Drop table
DROP TABLE IF EXISTS equipment_relationships CASCADE;
```

---

## âœ… Acceptance Criteria

- [ ] Equipment relationships table exists
- [ ] Historical relationships tracked
- [ ] Transfer function works
- [ ] Temporal queries work
- [ ] No data loss from migration
- [ ] Views provide easy access
- [ ] Documentation complete
- [ ] Zero downtime deployment

---

## ðŸ“Š Success Metrics

**Before:**
- âŒ Can't track equipment transfers
- âŒ No location change history
- âŒ Temporal queries impossible
- âŒ Lost audit trail

**After:**
- âœ… Complete ownership history
- âœ… Location changes tracked
- âœ… Query: "Who owned this on date X?"
- âœ… Full audit trail of all relationships

---

**Next:** Phase 2 - High Priority Fixes
