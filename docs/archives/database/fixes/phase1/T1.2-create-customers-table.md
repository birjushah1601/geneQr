# T1.2: Create Customers Table

**Priority:** Critical  
**Phase:** 1  
**Estimated Time:** 1.5 days  
**Dependencies:** None

---

## üéØ Problem Statement

### **Current Flawed Design:**

Customer information is **duplicated and scattered** across multiple tables:

```sql
-- service_tickets table
service_tickets (
    customer_id VARCHAR(32),        -- ‚ùå Just an ID, no actual customer table!
    customer_name VARCHAR(500),     -- ‚ùå Duplicated in every ticket
    customer_phone VARCHAR(20),     -- ‚ùå Duplicated in every ticket
    customer_whatsapp VARCHAR(20),  -- ‚ùå Duplicated in every ticket
    ...
)

-- equipment table (from ER diagram)
equipment (
    customer_contact_name VARCHAR(255),   -- ‚ùå Duplicated
    customer_contact_phone VARCHAR(20),   -- ‚ùå Duplicated
    customer_contact_email VARCHAR(255),  -- ‚ùå Duplicated
    ...
)
```

### **Critical Problems:**

1. ‚ùå **No Customer Entity** - `customer_id` references nothing!
2. ‚ùå **Data Duplication** - Same customer data repeated in every ticket
3. ‚ùå **Inconsistent Updates** - Customer changes phone ‚Üí must update all tickets manually
4. ‚ùå **No History** - Can't track: "What was customer's phone in January?"
5. ‚ùå **Poor Queries** - Can't query: "Show all customers from Mumbai with >10 tickets"
6. ‚ùå **Data Quality** - Customer "ABC Hospital" spelled 5 different ways
7. ‚ùå **No Relationships** - Can't link customers to organizations properly

### **Impact:**

- Customer service team wastes time searching for duplicate customers
- Phone numbers get outdated ‚Üí missed service calls
- Reporting is impossible (customer lifetime value, ticket frequency)
- Data integrity violations (orphaned customer_ids)

---

## ‚úÖ Correct Design

### **Normalized Customer Table:**

```sql
CREATE TABLE customers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Basic Information
    customer_type VARCHAR(50) NOT NULL,           -- 'individual', 'hospital', 'clinic', 'lab', 'manufacturer', 'dealer'
    name VARCHAR(500) NOT NULL,
    display_name VARCHAR(255),                    -- Short name for UI
    
    -- Contact Information
    primary_phone VARCHAR(20) NOT NULL,
    secondary_phone VARCHAR(20),
    primary_email VARCHAR(255),
    whatsapp_number VARCHAR(20),
    
    -- Address
    address_line1 VARCHAR(500),
    address_line2 VARCHAR(500),
    city VARCHAR(100),
    state VARCHAR(100),
    postal_code VARCHAR(20),
    country VARCHAR(100) DEFAULT 'India',
    
    -- Organization Link (if customer is linked to an org)
    organization_id UUID REFERENCES organizations(id),
    
    -- Business Details (for hospitals/clinics/labs)
    registration_number VARCHAR(100),              -- Hospital registration, GST, etc.
    tax_id VARCHAR(50),
    website VARCHAR(255),
    
    -- Status
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- active, inactive, blocked
    tier VARCHAR(50),                             -- vip, premium, standard (for prioritization)
    
    -- Preferences
    preferred_language VARCHAR(20) DEFAULT 'en',
    preferred_contact_method VARCHAR(50),         -- phone, email, whatsapp
    
    -- Metadata
    notes TEXT,
    tags JSONB DEFAULT '[]'::jsonb,               -- ["govt_hospital", "tier1_city", "high_value"]
    
    -- Audit
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by VARCHAR(255),
    
    CONSTRAINT customer_type_check CHECK (customer_type IN ('individual', 'hospital', 'clinic', 'lab', 'manufacturer', 'dealer')),
    CONSTRAINT customer_status_check CHECK (status IN ('active', 'inactive', 'blocked'))
);

-- Indexes for performance
CREATE INDEX idx_customers_type ON customers(customer_type);
CREATE INDEX idx_customers_phone ON customers(primary_phone);
CREATE INDEX idx_customers_email ON customers(primary_email);
CREATE INDEX idx_customers_org ON customers(organization_id);
CREATE INDEX idx_customers_status ON customers(status) WHERE status = 'active';
CREATE INDEX idx_customers_city_state ON customers(city, state);
CREATE INDEX idx_customers_name_trgm ON customers USING gin(name gin_trgm_ops); -- Full-text search

-- Unique constraint: same phone can't belong to multiple active customers
CREATE UNIQUE INDEX idx_customers_unique_phone ON customers(primary_phone) WHERE status = 'active';
```

### **Update service_tickets:**

```sql
-- Remove denormalized columns, keep only customer_id as foreign key
ALTER TABLE service_tickets
    DROP COLUMN IF EXISTS customer_name CASCADE,
    DROP COLUMN IF EXISTS customer_phone CASCADE,
    DROP COLUMN IF EXISTS customer_whatsapp CASCADE;

-- Add proper foreign key
ALTER TABLE service_tickets
    ADD CONSTRAINT fk_ticket_customer 
    FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE RESTRICT;
```

---

## üìã Migration Strategy

### **Phase 1: Create Table & Migrate Data**

```sql
-- 1. Create customers table
CREATE TABLE customers (...);

-- 2. Extract unique customers from service_tickets
INSERT INTO customers (
    id,
    customer_type,
    name,
    primary_phone,
    whatsapp_number,
    created_at,
    created_by
)
SELECT DISTINCT
    customer_id::uuid,
    'hospital' as customer_type,  -- Default, can be updated manually
    customer_name,
    customer_phone,
    customer_whatsapp,
    MIN(created_at) as created_at,
    'migration' as created_by
FROM service_tickets
WHERE customer_id IS NOT NULL 
    AND customer_id != ''
    AND customer_name IS NOT NULL
GROUP BY customer_id, customer_name, customer_phone, customer_whatsapp
ON CONFLICT (id) DO NOTHING;

-- 3. Handle customers without IDs (create new IDs)
WITH new_customers AS (
    SELECT DISTINCT
        customer_name,
        customer_phone,
        customer_whatsapp,
        MIN(created_at) as first_ticket_date
    FROM service_tickets
    WHERE (customer_id IS NULL OR customer_id = '')
        AND customer_name IS NOT NULL
    GROUP BY customer_name, customer_phone, customer_whatsapp
)
INSERT INTO customers (
    customer_type,
    name,
    primary_phone,
    whatsapp_number,
    created_at,
    created_by
)
SELECT
    'hospital' as customer_type,
    customer_name,
    customer_phone,
    customer_whatsapp,
    first_ticket_date,
    'migration' as created_by
FROM new_customers;

-- 4. Update tickets to reference new customer IDs
-- (for tickets that didn't have customer_id)
UPDATE service_tickets st
SET customer_id = c.id::text
FROM customers c
WHERE st.customer_name = c.name
    AND st.customer_phone = c.primary_phone
    AND (st.customer_id IS NULL OR st.customer_id = '');
```

### **Phase 2: Add Constraints (After Validation)**

```sql
-- Make customer_id NOT NULL after all tickets are linked
ALTER TABLE service_tickets
    ALTER COLUMN customer_id SET NOT NULL;

-- Add foreign key
ALTER TABLE service_tickets
    ADD CONSTRAINT fk_ticket_customer 
    FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE RESTRICT;
```

### **Phase 3: Deprecate Old Columns (Gradual)**

```sql
-- Rename old columns for backward compatibility during transition
ALTER TABLE service_tickets
    RENAME COLUMN customer_name TO customer_name_deprecated;
ALTER TABLE service_tickets
    RENAME COLUMN customer_phone TO customer_phone_deprecated;
ALTER TABLE service_tickets
    RENAME COLUMN customer_whatsapp TO customer_whatsapp_deprecated;

-- Add comments
COMMENT ON COLUMN service_tickets.customer_name_deprecated IS 
    'DEPRECATED: Use customers.name via customer_id foreign key. Will be dropped in 30 days.';
```

---

## üíª Backend Changes

### **1. Domain Model** (`internal/customer/domain/customer.go`)

```go
package domain

import (
    "errors"
    "time"
)

var (
    ErrCustomerNotFound = errors.New("customer not found")
    ErrInvalidPhone     = errors.New("invalid phone number")
    ErrDuplicateCustomer = errors.New("customer with this phone already exists")
)

type CustomerType string

const (
    CustomerTypeIndividual   CustomerType = "individual"
    CustomerTypeHospital     CustomerType = "hospital"
    CustomerTypeClinic       CustomerType = "clinic"
    CustomerTypeLab          CustomerType = "lab"
    CustomerTypeManufacturer CustomerType = "manufacturer"
    CustomerTypeDealer       CustomerType = "dealer"
)

type CustomerStatus string

const (
    CustomerStatusActive   CustomerStatus = "active"
    CustomerStatusInactive CustomerStatus = "inactive"
    CustomerStatusBlocked  CustomerStatus = "blocked"
)

type Customer struct {
    ID                   string         `json:"id"`
    CustomerType         CustomerType   `json:"customer_type"`
    Name                 string         `json:"name"`
    DisplayName          string         `json:"display_name,omitempty"`
    
    // Contact
    PrimaryPhone         string         `json:"primary_phone"`
    SecondaryPhone       string         `json:"secondary_phone,omitempty"`
    PrimaryEmail         string         `json:"primary_email,omitempty"`
    WhatsAppNumber       string         `json:"whatsapp_number,omitempty"`
    
    // Address
    AddressLine1         string         `json:"address_line1,omitempty"`
    AddressLine2         string         `json:"address_line2,omitempty"`
    City                 string         `json:"city,omitempty"`
    State                string         `json:"state,omitempty"`
    PostalCode           string         `json:"postal_code,omitempty"`
    Country              string         `json:"country"`
    
    // Organization
    OrganizationID       string         `json:"organization_id,omitempty"`
    
    // Business
    RegistrationNumber   string         `json:"registration_number,omitempty"`
    TaxID                string         `json:"tax_id,omitempty"`
    Website              string         `json:"website,omitempty"`
    
    // Status
    Status               CustomerStatus `json:"status"`
    Tier                 string         `json:"tier,omitempty"`
    
    // Preferences
    PreferredLanguage    string         `json:"preferred_language"`
    PreferredContactMethod string       `json:"preferred_contact_method,omitempty"`
    
    // Metadata
    Notes                string         `json:"notes,omitempty"`
    Tags                 []string       `json:"tags,omitempty"`
    
    // Audit
    CreatedAt            time.Time      `json:"created_at"`
    UpdatedAt            time.Time      `json:"updated_at"`
    CreatedBy            string         `json:"created_by"`
}

// NewCustomer creates a new customer
func NewCustomer(customerType CustomerType, name, phone, createdBy string) (*Customer, error) {
    if name == "" {
        return nil, errors.New("customer name is required")
    }
    if phone == "" {
        return nil, ErrInvalidPhone
    }
    
    return &Customer{
        ID:                generateCustomerID(),
        CustomerType:      customerType,
        Name:              name,
        PrimaryPhone:      phone,
        Status:            CustomerStatusActive,
        PreferredLanguage: "en",
        Country:           "India",
        CreatedAt:         time.Now(),
        UpdatedAt:         time.Now(),
        CreatedBy:         createdBy,
    }, nil
}

// UpdateContact updates customer contact information
func (c *Customer) UpdateContact(phone, email, whatsapp string) {
    if phone != "" {
        c.PrimaryPhone = phone
    }
    if email != "" {
        c.PrimaryEmail = email
    }
    if whatsapp != "" {
        c.WhatsAppNumber = whatsapp
    }
    c.UpdatedAt = time.Now()
}

// Block blocks the customer
func (c *Customer) Block(reason string) error {
    if c.Status == CustomerStatusBlocked {
        return errors.New("customer already blocked")
    }
    c.Status = CustomerStatusBlocked
    c.Notes += "\nBlocked: " + reason
    c.UpdatedAt = time.Now()
    return nil
}

// Activate activates the customer
func (c *Customer) Activate() error {
    if c.Status == CustomerStatusActive {
        return errors.New("customer already active")
    }
    c.Status = CustomerStatusActive
    c.UpdatedAt = time.Now()
    return nil
}
```

### **2. Repository Interface**

```go
package domain

import "context"

type CustomerRepository interface {
    Create(ctx context.Context, customer *Customer) error
    Update(ctx context.Context, customer *Customer) error
    GetByID(ctx context.Context, id string) (*Customer, error)
    GetByPhone(ctx context.Context, phone string) (*Customer, error)
    SearchByName(ctx context.Context, query string, limit int) ([]*Customer, error)
    List(ctx context.Context, filters CustomerFilters, limit, offset int) ([]*Customer, error)
    Count(ctx context.Context, filters CustomerFilters) (int, error)
}

type CustomerFilters struct {
    CustomerType   CustomerType
    Status         CustomerStatus
    City           string
    State          string
    OrganizationID string
}
```

---

## üß™ Testing Checklist

### **Database Migration:**
- [ ] Create customers table successfully
- [ ] All unique customers extracted from service_tickets
- [ ] Duplicate customers handled correctly
- [ ] Foreign key constraints working
- [ ] Indexes created and performant
- [ ] Rollback script works

### **Data Validation:**
- [ ] No orphaned customer_ids in service_tickets
- [ ] Customer phone numbers valid
- [ ] No duplicate active customers with same phone
- [ ] All service tickets have valid customer reference

### **Backend:**
- [ ] Customer domain model created
- [ ] Repository implemented
- [ ] Service layer created
- [ ] API endpoints working
- [ ] Search by name/phone works
- [ ] Unit tests pass
- [ ] Integration tests pass

### **Performance:**
- [ ] Customer lookup by ID < 10ms
- [ ] Search by name < 50ms
- [ ] Ticket creation with customer reference < 100ms
- [ ] No N+1 query issues

---

## üîÑ Rollback Procedure

```sql
-- 1. Remove foreign key constraint
ALTER TABLE service_tickets DROP CONSTRAINT IF EXISTS fk_ticket_customer;

-- 2. Restore denormalized columns
ALTER TABLE service_tickets
    ADD COLUMN customer_name VARCHAR(500),
    ADD COLUMN customer_phone VARCHAR(20),
    ADD COLUMN customer_whatsapp VARCHAR(20);

-- 3. Backfill from customers table
UPDATE service_tickets st
SET 
    customer_name = c.name,
    customer_phone = c.primary_phone,
    customer_whatsapp = c.whatsapp_number
FROM customers c
WHERE st.customer_id = c.id::text;

-- 4. Drop customers table
DROP TABLE IF EXISTS customers CASCADE;
```

---

## ‚úÖ Acceptance Criteria

- [ ] Customers table exists with all required fields
- [ ] All service tickets reference valid customers
- [ ] No duplicate customer records
- [ ] Customer search works (by name, phone, ID)
- [ ] API endpoints functional
- [ ] Documentation complete
- [ ] Zero downtime deployment
- [ ] Performance benchmarks met

---

## üìä Success Metrics

**Before:**
- ‚ùå Customer data duplicated in 247 service tickets
- ‚ùå No way to track customer history
- ‚ùå Customer queries impossible

**After:**
- ‚úÖ Single source of truth for customers
- ‚úÖ Can track all tickets per customer
- ‚úÖ Can query: "Top 10 customers by ticket volume"
- ‚úÖ Customer phone update affects all tickets automatically

---

## üöÄ Deployment Steps

1. **Dev Environment** - Test migration, validate data
2. **Staging** - Run migration, performance testing
3. **Production (Off-peak)** - Execute in transaction with instant rollback capability
4. **Monitor** - Watch for errors, performance issues
5. **Validate** - Run validation queries, check data integrity
6. **Cleanup** - After 30 days, drop deprecated columns

---

**Next:** [T1.3: Normalize RFQ/Quote Items](./T1.3-normalize-rfq-quote-items.md)
