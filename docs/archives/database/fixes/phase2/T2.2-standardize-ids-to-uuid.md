# T2.2: Standardize IDs to UUID

**Priority:** High  
**Phase:** 2  
**Estimated Time:** 2 days  
**Risk Level:** ‚ö†Ô∏è High (affects foreign keys)  
**Dependencies:** None

---

## üéØ Problem Statement

### **Current Inconsistent ID Types:**

The database has **mixed ID types** across tables, causing confusion and complexity:

```sql
-- UUID (good!)
organizations (id UUID)
org_relationships (id UUID)
engineers (id UUID)

-- VARCHAR(32) - ULID format
equipment_registry (id VARCHAR(32))
service_tickets (id VARCHAR(32))
quotes (id VARCHAR(32))

-- VARCHAR(26) - Different length!
rfqs (id VARCHAR(26))
rfq_items (id VARCHAR(26))

-- VARCHAR(50) - Way too long!
some_other_tables (id VARCHAR(50))

-- SERIAL/BIGSERIAL (integer)
quote_revisions (id SERIAL)
```

### **Critical Problems:**

1. ‚ùå **Inconsistency Confusion**
   - Developers don't know which ID type to use
   - Foreign keys have mismatched types
   - Code has to handle multiple ID formats

2. ‚ùå **Type Conversion Overhead**
   - VARCHAR ‚Üí UUID conversions needed for joins
   - Performance penalty for type casting
   - Index inefficiencies

3. ‚ùå **Storage Waste**
   - VARCHAR(32) uses 32 bytes
   - VARCHAR(26) uses 26 bytes  
   - UUID uses only 16 bytes (50% smaller!)

4. ‚ùå **Join Complexity**
   ```sql
   -- Current (ugly):
   SELECT * FROM organizations o
   JOIN equipment e ON o.id::text = e.owner_id
   
   -- What we want:
   SELECT * FROM organizations o
   JOIN equipment e ON o.id = e.owner_id
   ```

5. ‚ùå **Application Code Complexity**
   - Go code has to handle: `uuid.UUID`, `string`, `int64`
   - Different ID generators (ULID, UUID, auto-increment)
   - Serialization inconsistencies

6. ‚ùå **Migration Nightmares**
   - Hard to standardize later (we're here now!)
   - Breaking changes to foreign keys
   - Data migration complexity

---

## ‚úÖ Correct Design

### **UUID for Everything:**

```sql
-- Standard across ALL tables:
CREATE TABLE table_name (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ...
);

-- Keep human-readable codes separately:
CREATE TABLE equipment_registry (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    equipment_code VARCHAR(50) UNIQUE,  -- 'EQ-2024-001'
    serial_number VARCHAR(255) UNIQUE,
    ...
);

CREATE TABLE service_tickets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_number VARCHAR(50) UNIQUE,   -- 'TKT-2024-001'
    ...
);
```

### **Benefits:**

‚úÖ **Consistency** - One ID type everywhere  
‚úÖ **Performance** - No type conversions, better indexes  
‚úÖ **Storage** - UUID is 16 bytes (VARCHAR(32) is 32 bytes)  
‚úÖ **Security** - UUIDs are non-sequential (no ID enumeration attacks)  
‚úÖ **Simplicity** - Clean joins, simpler code  
‚úÖ **Distributed** - UUID generation works across servers

---

## üìã Current State Analysis

### **Tables Using UUID** ‚úÖ
- `organizations`
- `organization_facilities`
- `org_relationships`
- `org_relationship_terms` (T2.1)
- `equipment_relationships` (T1.4)
- `territories`
- `contact_persons`
- `organization_certifications`
- `engineers`
- `engineer_assignments` (T1.1)

### **Tables Using VARCHAR IDs** ‚ùå
- `equipment_registry` - VARCHAR(32)
- `equipment_catalog` - VARCHAR(32)
- `equipment_categories` - VARCHAR(32)
- `service_tickets` - VARCHAR(32)
- `quotes` - VARCHAR(32)
- `quote_items` - VARCHAR(32)
- `rfqs` - VARCHAR(26)
- `rfq_items` - VARCHAR(26)
- `rfq_invitations` - VARCHAR(26)
- `customers` (T1.2) - VARCHAR(32)
- `contracts` - VARCHAR(32)

### **Tables Using SERIAL/INT** ‚ùå
- `quote_revisions` - SERIAL

---

## üîß Migration Strategy

### **Approach: Dual-ID Pattern (Zero Downtime)**

We can't just change ID types - too risky! Instead:

**Phase 1: Add UUID columns**
```sql
-- Add new UUID column (nullable initially)
ALTER TABLE equipment_registry
ADD COLUMN uuid_id UUID DEFAULT gen_random_uuid(),
ADD COLUMN legacy_id VARCHAR(32);

-- Copy existing IDs to legacy
UPDATE equipment_registry SET legacy_id = id;

-- Generate UUIDs for existing records
UPDATE equipment_registry SET uuid_id = gen_random_uuid() WHERE uuid_id IS NULL;

-- Make UUID NOT NULL
ALTER TABLE equipment_registry ALTER COLUMN uuid_id SET NOT NULL;

-- Add unique constraint
ALTER TABLE equipment_registry ADD CONSTRAINT equipment_registry_uuid_id_key UNIQUE (uuid_id);
```

**Phase 2: Update Foreign Keys (Dual columns)**
```sql
-- Example: service_tickets references equipment
ALTER TABLE service_tickets
ADD COLUMN equipment_uuid UUID;

-- Populate from equipment_registry
UPDATE service_tickets st
SET equipment_uuid = er.uuid_id
FROM equipment_registry er
WHERE st.equipment_id = er.id;

-- Add FK constraint
ALTER TABLE service_tickets
ADD CONSTRAINT fk_service_tickets_equipment_uuid
FOREIGN KEY (equipment_uuid) REFERENCES equipment_registry(uuid_id);
```

**Phase 3: Application Code Update**
- Phase 3a: Read from both columns (backward compatible)
- Phase 3b: Write to both columns
- Phase 3c: Switch to UUID-only reads
- Phase 3d: Drop legacy columns

**Phase 4: Swap Primary Key**
```sql
-- Drop old PK
ALTER TABLE equipment_registry DROP CONSTRAINT equipment_registry_pkey;

-- Make UUID the new PK
ALTER TABLE equipment_registry ADD PRIMARY KEY (uuid_id);

-- Rename columns
ALTER TABLE equipment_registry RENAME COLUMN uuid_id TO id;
ALTER TABLE equipment_registry RENAME COLUMN id TO legacy_id;
```

**Phase 5: Cleanup (After testing)**
```sql
-- Drop legacy columns
ALTER TABLE equipment_registry DROP COLUMN legacy_id;

-- Drop old FK constraints
ALTER TABLE service_tickets DROP COLUMN equipment_id;
```

---

## üìä Tables Priority for Migration

### **High Priority** (Most referenced)
1. `equipment_registry` - Referenced by tickets, relationships
2. `service_tickets` - Core business entity
3. `customers` (T1.2) - Referenced by RFQs, quotes, tickets
4. `equipment_catalog` - Referenced by many tables
5. `rfqs` - Referenced by quotes, invitations

### **Medium Priority**
6. `quotes` - Referenced by quote_items
7. `equipment_categories` - Referenced by catalog
8. `contracts` - Referenced by relationships

### **Low Priority**
9. `rfq_items`, `quote_items` - Child tables
10. `rfq_invitations` - Support table

---

## ‚ö†Ô∏è Risks & Mitigation

### **Risk 1: Breaking Foreign Keys**
**Mitigation:** Dual-ID pattern keeps both old and new during transition

### **Risk 2: Application Code Breaks**
**Mitigation:** Gradual rollout, feature flags, dual-column reads

### **Risk 3: Data Loss**
**Mitigation:** Keep legacy columns until fully migrated and tested

### **Risk 4: Performance During Migration**
**Mitigation:** 
- Migrate in batches (not all at once)
- Run during low-traffic periods
- Monitor query performance

### **Risk 5: Join Complexity**
**Mitigation:** Views provide backward compatibility

---

## üß™ Testing Strategy

### **Pre-Migration**
- [ ] Identify all foreign key relationships
- [ ] Document current ID formats
- [ ] Create rollback scripts

### **During Migration**
- [ ] Test dual-column reads
- [ ] Verify FK constraints work
- [ ] Check application endpoints
- [ ] Monitor performance

### **Post-Migration**
- [ ] All queries use UUID
- [ ] No type casting in JOINs
- [ ] Foreign keys intact
- [ ] Application stable

---

## üìù Example Migration Script

```sql
-- =============================================================================
-- Example: Migrate equipment_registry to UUID
-- =============================================================================

BEGIN;

-- Step 1: Add UUID column
ALTER TABLE equipment_registry
ADD COLUMN uuid_id UUID DEFAULT gen_random_uuid(),
ADD COLUMN legacy_varchar_id VARCHAR(32);

-- Step 2: Copy existing IDs
UPDATE equipment_registry SET legacy_varchar_id = id;

-- Step 3: Make UUID primary
ALTER TABLE equipment_registry ALTER COLUMN uuid_id SET NOT NULL;
CREATE UNIQUE INDEX idx_equipment_uuid ON equipment_registry(uuid_id);

-- Step 4: Update referencing tables (equipment_relationships example)
ALTER TABLE equipment_relationships
ADD COLUMN equipment_uuid UUID;

UPDATE equipment_relationships er
SET equipment_uuid = e.uuid_id
FROM equipment_registry e
WHERE er.equipment_id = e.id;

ALTER TABLE equipment_relationships
ADD CONSTRAINT fk_equipment_rel_equipment_uuid
FOREIGN KEY (equipment_uuid) REFERENCES equipment_registry(uuid_id);

-- Step 5: Create view for backward compatibility
CREATE OR REPLACE VIEW equipment_registry_compat AS
SELECT
    uuid_id as id,
    legacy_varchar_id as old_id,
    equipment_code,
    serial_number,
    equipment_name,
    ... -- all other columns
FROM equipment_registry;

COMMIT;
```

---

## üéØ Acceptance Criteria

- [ ] All tables use UUID as PRIMARY KEY
- [ ] No VARCHAR or INT IDs remain (except legacy columns during transition)
- [ ] All foreign keys use UUID
- [ ] No type casting in JOIN queries
- [ ] Application code uses uuid.UUID type
- [ ] Performance maintained or improved
- [ ] Zero data loss
- [ ] Rollback scripts tested

---

## üîÑ Rollback Procedure

```sql
-- If migration fails, swap back:
ALTER TABLE equipment_registry DROP CONSTRAINT equipment_registry_pkey;
ALTER TABLE equipment_registry ADD PRIMARY KEY (legacy_varchar_id);
ALTER TABLE equipment_registry RENAME COLUMN legacy_varchar_id TO id;
ALTER TABLE equipment_registry DROP COLUMN uuid_id;

-- Drop new FK constraints
ALTER TABLE equipment_relationships DROP CONSTRAINT fk_equipment_rel_equipment_uuid;
ALTER TABLE equipment_relationships DROP COLUMN equipment_uuid;
```

---

## üí° Alternative Approach (Lower Risk)

**Option 1:** Standardize on VARCHAR(36) for UUID text representation
- Pro: No type changes needed
- Con: Wastes storage, still inconsistent lengths

**Option 2:** Keep current, add UUID only for NEW tables
- Pro: No migration needed
- Con: Problem persists, gets worse over time

**Option 3:** Our chosen approach (Dual-ID pattern)
- Pro: Zero downtime, reversible, thorough
- Con: Takes longer, more complex

---

## üìà Expected Outcomes

### **Before T2.2:**
- ‚ùå Mixed ID types (UUID, VARCHAR(32), VARCHAR(26), SERIAL)
- ‚ùå Type casting in queries: `o.id::text = e.equipment_id`
- ‚ùå Developer confusion
- ‚ùå Storage waste

### **After T2.2:**
- ‚úÖ UUID everywhere
- ‚úÖ Clean joins: `o.id = e.owner_id`
- ‚úÖ Consistent codebase
- ‚úÖ 50% storage savings on IDs
- ‚úÖ Better performance

---

**Status:** üü° Ready for Implementation  
**Recommendation:** Start with `equipment_registry` (most critical)

**Next:** Create migration script for equipment_registry ‚Üí UUID

This is the **foundation fix** that makes everything else cleaner! üöÄ
