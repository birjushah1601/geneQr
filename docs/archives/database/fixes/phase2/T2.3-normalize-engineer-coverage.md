# T2.3: Normalize Engineer Coverage

**Priority:** High  
**Phase:** 2  
**Estimated Time:** 1 day  
**Risk Level:** ðŸŸ¢ Low  
**Dependencies:** None

---

## ðŸŽ¯ Problem Statement

### **Current Flawed Design:**

Engineer coverage is stored as **JSONB arrays** in the engineers table:

```sql
engineers (
    id UUID PRIMARY KEY,
    full_name TEXT,
    org_id UUID,
    
    -- âŒ PROBLEM: Coverage as arrays - hard to query!
    coverage_pincodes TEXT[],       -- ['400001', '400002', '400003']
    coverage_cities TEXT[],         -- ['Mumbai', 'Navi Mumbai', 'Thane']
    coverage_states TEXT[],         -- ['Maharashtra', 'Gujarat']
    coverage_radius_km INT,         -- 50
    home_region TEXT                -- 'Western Region'
);
```

### **Critical Problems:**

1. âŒ **Can't Query "Who covers pincode X?"**
   ```sql
   -- Current (ugly and slow):
   SELECT * FROM engineers
   WHERE '400001' = ANY(coverage_pincodes);
   
   -- Doesn't use indexes efficiently!
   ```

2. âŒ **Can't Join with Territories**
   ```sql
   -- Want: Get all engineers for territory T1
   -- Current: Have to unnest arrays, complex query
   ```

3. âŒ **No Temporal Tracking**
   - Engineer coverage changed: Mumbai â†’ Pune
   - When did this change? No history!
   - Can't track: "Who was covering Bangalore in Jan 2024?"

4. âŒ **No Priority/Assignment Logic**
   - Multiple engineers cover same pincode
   - Who gets assigned first?
   - No primary/secondary concept

5. âŒ **Hard to Maintain**
   - Updating coverage = updating array
   - No referential integrity
   - Can have invalid pincodes

6. âŒ **Poor Query Performance**
   - Array queries are slow
   - GIN indexes help but not optimal
   - Can't do efficient range queries

---

## âœ… Correct Design

### **Separate Coverage Areas Table:**

```sql
-- Main engineers table (clean!)
engineers (
    id UUID PRIMARY KEY,
    full_name TEXT,
    org_id UUID,
    primary_facility_id UUID,
    mobile_engineer BOOLEAN,
    current_location POINT,
    status TEXT,
    ... -- other personal fields
);

-- Coverage areas (normalized!)
engineer_coverage_areas (
    id UUID PRIMARY KEY,
    engineer_id UUID FK,
    
    -- Coverage definition
    coverage_type TEXT,             -- 'pincode', 'city', 'district', 'state'
    coverage_value TEXT,            -- Actual pincode/city/state value
    
    -- Territory link
    territory_id UUID FK,           -- Link to territories table
    
    -- Priority
    priority INT DEFAULT 1,         -- 1=primary, 2=secondary, 3=tertiary
    coverage_radius_km INT,         -- Radius for location-based assignment
    
    -- Temporal validity
    effective_from DATE,
    effective_to DATE,              -- NULL = currently active
    
    -- Assignment rules
    can_emergency BOOLEAN DEFAULT true,
    can_scheduled BOOLEAN DEFAULT true,
    max_concurrent_tickets INT DEFAULT 3,
    
    -- Metadata
    assigned_by TEXT,
    assignment_reason TEXT,
    notes TEXT,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### **Benefits:**

âœ… **Fast Queries** - Direct index lookups  
âœ… **Easy Joins** - Natural relationship with territories  
âœ… **Temporal Tracking** - Know coverage at any point in time  
âœ… **Priority System** - Assign primary engineer first  
âœ… **History** - Complete audit trail of coverage changes  
âœ… **Flexibility** - Can add territory hierarchy

---

## ðŸ”§ Key Features

### **1. Fast "Who Covers?" Queries**
```sql
-- Get all engineers covering a pincode
SELECT e.* FROM engineers e
JOIN engineer_coverage_areas eca ON e.id = eca.engineer_id
WHERE eca.coverage_type = 'pincode'
    AND eca.coverage_value = '400001'
    AND eca.effective_to IS NULL
ORDER BY eca.priority ASC;

-- Uses index! Super fast!
```

### **2. Territory-Based Assignment**
```sql
-- Get all engineers for territory
SELECT e.* FROM engineers e
JOIN engineer_coverage_areas eca ON e.id = eca.engineer_id
WHERE eca.territory_id = 'territory-uuid'
    AND eca.effective_to IS NULL
    AND e.status = 'available';
```

### **3. Temporal Queries**
```sql
-- Who was covering Mumbai in January 2024?
SELECT e.full_name, eca.priority
FROM engineers e
JOIN engineer_coverage_areas eca ON e.id = eca.engineer_id
WHERE eca.coverage_type = 'city'
    AND eca.coverage_value = 'Mumbai'
    AND '2024-01-15' BETWEEN eca.effective_from AND COALESCE(eca.effective_to, '9999-12-31');
```

### **4. Priority-Based Assignment**
```sql
-- Get primary engineer for pincode (for auto-assignment)
SELECT e.* FROM engineers e
JOIN engineer_coverage_areas eca ON e.id = eca.engineer_id
WHERE eca.coverage_type = 'pincode'
    AND eca.coverage_value = '400001'
    AND eca.priority = 1
    AND eca.effective_to IS NULL
    AND e.status = 'available'
LIMIT 1;
```

### **5. Coverage History**
```sql
-- Track engineer's coverage changes
SELECT
    coverage_type,
    coverage_value,
    effective_from,
    effective_to,
    priority,
    assignment_reason
FROM engineer_coverage_areas
WHERE engineer_id = 'engineer-uuid'
ORDER BY effective_from DESC;
```

---

## ðŸ“‹ Migration Strategy

### **Step 1: Create New Table**
```sql
CREATE TABLE engineer_coverage_areas (...);
CREATE INDEXES ...;
```

### **Step 2: Migrate Existing Data**
```sql
-- Migrate pincodes
INSERT INTO engineer_coverage_areas (
    engineer_id, coverage_type, coverage_value, 
    priority, effective_from, assigned_by, assignment_reason
)
SELECT 
    e.id as engineer_id,
    'pincode' as coverage_type,
    unnest(e.coverage_pincodes) as coverage_value,
    1 as priority,
    COALESCE(e.joining_date, e.created_at) as effective_from,
    'migration_T2.3' as assigned_by,
    'Migrated from engineers.coverage_pincodes' as assignment_reason
FROM engineers e
WHERE e.coverage_pincodes IS NOT NULL 
    AND array_length(e.coverage_pincodes, 1) > 0;

-- Migrate cities
INSERT INTO engineer_coverage_areas (...)
SELECT ...
FROM engineers e
WHERE e.coverage_cities IS NOT NULL...;

-- Migrate states
INSERT INTO engineer_coverage_areas (...)
SELECT ...
FROM engineers e
WHERE e.coverage_states IS NOT NULL...;
```

### **Step 3: Create Helper Views**
```sql
-- View: Engineers with current coverage (backward compat)
CREATE VIEW engineers_with_coverage AS
SELECT
    e.*,
    array_agg(DISTINCT eca.coverage_value) FILTER (
        WHERE eca.coverage_type = 'pincode' AND eca.effective_to IS NULL
    ) as current_pincodes,
    array_agg(DISTINCT eca.coverage_value) FILTER (
        WHERE eca.coverage_type = 'city' AND eca.effective_to IS NULL
    ) as current_cities,
    array_agg(DISTINCT eca.coverage_value) FILTER (
        WHERE eca.coverage_type = 'state' AND eca.effective_to IS NULL
    ) as current_states
FROM engineers e
LEFT JOIN engineer_coverage_areas eca ON e.id = eca.engineer_id
GROUP BY e.id;
```

### **Step 4: Update Application Code**
- Phase 1: Read from view (backward compatible)
- Phase 2: Update writes to use new table
- Phase 3: Switch to direct queries
- Phase 4: Drop old columns

### **Step 5: Remove Old Columns**
```sql
-- After all code updated
ALTER TABLE engineers
DROP COLUMN coverage_pincodes,
DROP COLUMN coverage_cities,
DROP COLUMN coverage_states,
DROP COLUMN coverage_radius_km,
DROP COLUMN home_region;
```

---

## ðŸ’¡ Use Case Examples

### **Example 1: Add Coverage for New Engineer**
```sql
-- Engineer joins, assigned to cover 5 pincodes in Mumbai
INSERT INTO engineer_coverage_areas (
    engineer_id, coverage_type, coverage_value, 
    priority, effective_from, assigned_by
)
VALUES
    ('eng-123', 'pincode', '400001', 1, NOW(), 'manager@company.com'),
    ('eng-123', 'pincode', '400002', 1, NOW(), 'manager@company.com'),
    ('eng-123', 'pincode', '400003', 1, NOW(), 'manager@company.com'),
    ('eng-123', 'city', 'Mumbai', 1, NOW(), 'manager@company.com');
```

### **Example 2: Transfer Coverage (Mumbai â†’ Pune)**
```sql
-- Close Mumbai coverage
UPDATE engineer_coverage_areas
SET effective_to = NOW(),
    notes = 'Engineer transferred to Pune region'
WHERE engineer_id = 'eng-123'
    AND coverage_value = 'Mumbai'
    AND effective_to IS NULL;

-- Add Pune coverage
INSERT INTO engineer_coverage_areas (
    engineer_id, coverage_type, coverage_value,
    priority, effective_from, assigned_by, assignment_reason
)
VALUES
    ('eng-123', 'city', 'Pune', 1, NOW(), 'manager@company.com', 'Regional transfer');
```

### **Example 3: Add Secondary Engineer (Backup)**
```sql
-- Primary engineer for 400001 is eng-123
-- Add eng-456 as secondary (backup)
INSERT INTO engineer_coverage_areas (
    engineer_id, coverage_type, coverage_value,
    priority, effective_from, assignment_reason
)
VALUES
    ('eng-456', 'pincode', '400001', 2, NOW(), 'Backup for peak load periods');
```

### **Example 4: Find Available Engineer for Service Ticket**
```sql
-- Customer in pincode 400001 needs service
SELECT 
    e.id,
    e.full_name,
    e.current_location,
    eca.priority,
    e.active_tickets
FROM engineers e
JOIN engineer_coverage_areas eca ON e.id = eca.engineer_id
WHERE eca.coverage_type = 'pincode'
    AND eca.coverage_value = '400001'
    AND eca.effective_to IS NULL
    AND e.status = 'available'
    AND e.active_tickets < e.max_daily_tickets
ORDER BY eca.priority ASC, e.active_tickets ASC
LIMIT 1;
```

### **Example 5: Coverage Gap Analysis**
```sql
-- Find pincodes with no engineer coverage
SELECT DISTINCT pincode
FROM customer_locations
WHERE pincode NOT IN (
    SELECT coverage_value
    FROM engineer_coverage_areas
    WHERE coverage_type = 'pincode'
        AND effective_to IS NULL
);
```

---

## ðŸ“Š Benefits

### **Before T2.3:**
- âŒ Coverage as arrays (slow queries)
- âŒ Can't track history
- âŒ No priority system
- âŒ Hard to find available engineer
- âŒ No territory integration

### **After T2.3:**
- âœ… Fast indexed queries
- âœ… Complete coverage history
- âœ… Primary/secondary engineer concept
- âœ… Easy engineer assignment algorithm
- âœ… Territory-based management

---

## ðŸ§ª Testing Checklist

- [ ] engineer_coverage_areas table created
- [ ] All indexes created
- [ ] Data migrated from arrays
- [ ] Backward compatible view works
- [ ] "Who covers X?" queries fast
- [ ] Temporal queries work
- [ ] Priority-based assignment works
- [ ] No data loss

---

## ðŸ”„ Rollback Procedure

```sql
-- Drop new structures
DROP VIEW IF EXISTS engineers_with_coverage CASCADE;
DROP TABLE IF EXISTS engineer_coverage_areas CASCADE;

-- Old array columns remain in engineers table
```

---

## âœ… Acceptance Criteria

- [ ] Coverage stored in normalized table
- [ ] Fast pincode/city/state queries (<50ms)
- [ ] Temporal tracking enabled
- [ ] Priority system works
- [ ] Zero downtime migration
- [ ] Backward compatible view
- [ ] Complete coverage history

---

**Status:** ðŸŸ¡ Ready for Implementation  
**Next:** Create SQL migration script

This is **simpler than T2.2** and provides immediate query performance benefits! ðŸš€
